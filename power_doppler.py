# -*- coding: utf-8 -*-
"""Power_Doppler

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e7Kuq8LXGvT1lJp8UOdAlDzb5S4-u8Tx
"""

from scipy.io import loadmat
import matplotlib.pyplot as plt
import numpy as np
from scipy.ndimage import gaussian_filter
from scipy.stats import linregress

#load data
data = loadmat("/content/drive/MyDrive/flow_data_full.mat")
rawImages = data['raw_frame_cell']

# forces
rawImages = np.stack(rawImages.flatten(order='F'))
rawImagesReordered = np.transpose(rawImages, (1, 2, 0))
print(rawImagesReordered.shape)
imShape = rawImagesReordered.shape
numFrames = rawImagesReordered.shape[-1]
flatImages = np.reshape(rawImagesReordered, (-1, numFrames), order='F')
print(flatImages.shape)
filteredImages = np.stack(data['filtered_frame_cell'].flatten(order='F'))

# readi

# combinedImages = np.zeros((16, 300, 400), dtype='complex128')
# for i in range(rawImages.shape[0]):
#     images = np.stack(rawImages[i])
#     combinedImages[i, :, :] = np.mean(images, axis=0)

# rawImagesReordered = np.transpose(combinedImages, (1, 2, 0))
# print(rawImagesReordered.shape)
# imShape = rawImagesReordered.shape
# numFrames = rawImagesReordered.shape[-1]
# flatImages = np.reshape(rawImagesReordered, (-1, numFrames), order='F')
# print(flatImages.shape)
# filteredImages = np.stack(data['filtered_frame_cell'].flatten(order='F'))

(U, S, Vh) = np.linalg.svd(flatImages, full_matrices=False)

# plt.semilogy((S/np.max(S)))
# plt.show()

V = Vh.conj().T
PRF = 500
T = 1 / PRF

v1 = V[1:, :]
v0 = V[:-1, :]
product = v1 * np.conj(v0)

num = np.sum(np.imag(product), axis=0)
den = np.sum(np.real(product), axis=0)

omega = np.arctan2(num, den) / T
mean_freqs = np.abs(omega / (2 * np.pi))

plt.plot(20*np.log10(S/np.max(S)))
# plt.savefig('256_readi_16_forces_sigma.png')
plt.show()

plt.plot(mean_freqs)
# plt.savefig('256_readi_16_forces_MDF.png')

# plt.plot(np.arange(len(mean_freqs)), np.full(len(mean_freqs), 10))
# plt.plot(np.arange(len(mean_freqs)), np.full(len(mean_freqs), 200))
plt.show()

def makeFlow(images, maxMag, minMag, sigma):
  # sum the powers
  powerFlow = np.abs(images)**2
  averageFlow = powerFlow.mean(axis=0)
  # averageFlow = 10*np.log10(averageFlow/np.max(averageFlow))
  maxMag = np.percentile(averageFlow, maxMag)
  # assume power above maxMag is tissue
  averageFlow[averageFlow > maxMag] = 0

  averageFlow = gaussian_filter(averageFlow, sigma=sigma, mode='constant')

  flowArray = averageFlow

  cmap = plt.get_cmap('autumn')
  norm = plt.Normalize(np.min(flowArray), np.max(flowArray))

  rgbaFlow = cmap(norm(flowArray))
  #thresholding to retrieve relevant blood signal
  minMag = np.percentile(flowArray, minMag)
  transparencyMap = (flowArray>=minMag)

  rgbaFlow[:, :, -1] = transparencyMap.astype(float)
  return rgbaFlow

def reconstructSVD(tissue_threshold, noise_threshold):
  S_filtered = S.copy()
  S_filtered[0:tissue_threshold] = 0
  S_filtered[noise_threshold:len(S_filtered)] = 0

  filteredImages = U@np.diag(S_filtered)@Vh
  filteredImages = np.reshape(filteredImages, rawImagesReordered.shape, order='F')
  filteredImages = np.transpose(filteredImages, (2, 0, 1))
  return filteredImages

def makeBmode(images):
  # sum IQ data
  averageBmode = np.mean(images, axis=0)
  # envelope detection
  absBmode = np.abs(averageBmode)
  # logarithmic decomp
  log_env = 20*np.log10(absBmode/np.max(absBmode))
  log_env[log_env < -40] = -40
  BmodeArray = log_env
  return BmodeArray

# random svd

iters = 2
# k = expected singular value threshold for tissue
k = 17
d = 2
numFrames = rawImages.shape[0]
(xy, t) = flatImages.shape
omega = np.random.randn(t, k+d)
# project S onto a random lower dimensional matrix
SPrime = flatImages@omega
# Q = approximate orthonormal basis for S
Q,_ = np.linalg.qr(SPrime)
# power iterations to improve accuracy
for i in range(iters):
  # amplifies upper singular values, suppresses lower ones
  # ensures Q more closesly aligns with top k singular values
  Qi,_ = np.linalg.qr(flatImages.conj().T@Q)
  Q,_ = np.linalg.qr(flatImages@Qi)
A = Q.conj().T@flatImages
tissueClutter = Q@A
bloodSignal = flatImages - tissueClutter

bloodSignal = np.reshape(bloodSignal, rawImagesReordered.shape, order='F')
bloodSignal = np.transpose(bloodSignal, (2, 0, 1))

_,SRand,_ = np.linalg.svd(Q.conj().T@flatImages, full_matrices=False)
plt.plot(20*np.log10(S/np.max(S)))
plt.plot(20*np.log10(SRand/np.max(SRand)))
plt.show()

img = makeFlow(bloodSignal, 99.5, 0, 5.00)
plt.imshow(img)
plt.show()

def randomDownsample():
  nBases = 16
  xy, t = flatImages.shape

  rand_rows = np.random.permutation(xy)

  split_rows = np.array_split(rand_rows, nBases)

  filteredIm = np.zeros((xy, t), dtype='complex128')

  for i in range(nBases):
      row_indices = split_rows[i]
      submatrix = flatImages[row_indices, :]
      filtedSubmatrix = submatrix # do svd here
      filteredIm[row_indices, :] = filtedSubmatrix # reconstruction
  return filteredIm

# adaptive svd

# divides raw images into overlapping "blocks"
# for each block, compute SVD
# determine thresholds for svd based on singular value curve + mean doppler frequencies of the temporal singular vectors V
# reconstruct to get filtered signal for each block
# determine filtered signal for each pixel by averaging
def adaptiveSVD(blockSize, blockOverlap, tissueThreshold, noiseThreshold, images):

  step = blockSize - blockOverlap

  PRF = 500
  T = 1 / PRF
  x, z, t = images.shape

  numBlocksX = (x - blockSize) // step + 1
  numBlocksZ = (z - blockSize) // step + 1

  filteredImages = np.zeros((x, z, t), dtype='complex128')
  coverageMap = np.ones((x, z, t), dtype=int)

  for i in range(0, x-blockSize+1, step):
    for j in range(0, z-blockSize+1, step):

      coverageMap[i:i+blockSize, j:j+blockSize, :] += 1
      block = images[i:i+blockSize, j:j+blockSize, :]
      flatBlock = np.reshape(block, (-1, numFrames), order='F')

      (U, S, Vh) = np.linalg.svd(flatBlock,full_matrices=False)

      logS = 20*np.log10(S/np.max(S))
      second_derivative = np.diff(logS, n=2)
      elbowIndex = np.argmax(second_derivative) + 1
      thresholdIndex = np.argmax(logS >= tissueThreshold)

      lowerThreshold = np.max(elbowIndex, thresholdIndex)

      V = Vh.conj().T

      v0 = V[:-1, :]
      v1 = V[1:, :]
      product = v1 * np.conj(v0)

      num = np.sum(np.imag(product), axis=0)
      den = np.sum(np.real(product), axis=0)
      # mean angular frequency
      omega = np.arctan2(num, den) / T
      # mean doppler frequency
      mean_freqs = np.abs(omega / (2 * np.pi))

      fittingPoint = np.argmax(mean_freqs >= noiseThreshold)

      slope, intercept, *_ = linregress(np.arange(fittingPoint, len(logS)), logS[fittingPoint:])
      fittedSlope = slope * np.arange(len(logS)) + intercept
      diff = np.abs(logS - fittedSlope)

      diffThreshold = diff.mean() + 2*diff.std()
      upperThreshold = len(diff) - 1 - np.argmax(diff[::-1] >= diffThreshold)

      SFilt = S.copy()
      SFilt[0:lowerThreshold+1] = 0
      SFilt[upperThreshold:len(SFilt)] = 0
      filteredBlock = U@np.diag(SFilt)@Vh
      filteredBlock = np.reshape(filteredBlock, block.shape, order='F')
      SSum = sum(SFilt)
      print(SSum)
      filteredImages[i:i+blockSize, j:j+blockSize, :] += filteredBlock/SSum

      plt.plot(logS)
      plt.plot([lowerThreshold], [logS[lowerThreshold]], 'go')
      plt.plot([upperThreshold], [logS[upperThreshold]], 'ro')
      plt.show()

  filteredImages /= coverageMap
  filteredImages = np.transpose(filteredImages, (2, 0, 1))
  return filteredImages

from ipywidgets import IntSlider, FloatSlider, interactive_output, Output, Layout, HBox, VBox, Dropdown, Button, ToggleButtons
from IPython.display import display

bloodOut = Output()
powerDopplerOut = Output()
standardSVDOutput = Output()

def update(tissue_threshold, noise_threshold, maxMag, minMag, sigma, svdMode):
  if svdMode == 'Standard':
    standInputs.layout.display = 'flex'
    randInputs.layout.display = 'none'
    adaptiveInputs.layout.display = 'none'
  elif svdMode == 'Random':
    standInputs.layout.display = 'none'
    randInputs.layout.display = 'flex'
    adaptiveInputs.layout.display = 'none'
  else:
    standInputs.layout.display = 'none'
    randInputs.layout.display = 'none'
    adaptiveInputs.layout.display = 'flex'
  with bloodOut:
    bloodOut.clear_output(wait=True)
    plt.figure(figsize=(5, 5))
    filteredImages = reconstructSVD(tissue_threshold, noise_threshold)
    plt.title('Filtered Blood Signal')
    plt.imshow(makeFlow(filteredImages[0:16], maxMag, 0, sigma))
    plt.show()
  with powerDopplerOut:
    powerDopplerOut.clear_output(wait=True)
    bmodeArray = makeBmode(rawImages)
    plt.figure(figsize=(5, 5))
    plt.title('Power Doppler')
    plt.imshow(bmodeArray, cmap='grey')
    rgbaFlow = makeFlow(filteredImages[0:16], maxMag, minMag, sigma)
    plt.imshow(rgbaFlow)
    plt.show()

tissueSlider = IntSlider(
    min=0, max=256, step=1, value=0,
    description='Tissue Threshold:',
    continuous_update=False,
    style={'description_width': '130px'},
    layout=Layout(width='400px')
)

noiseSlider = IntSlider(
    min=0, max=256, step=1, value=256,
    description='Noise Threshold:',
    continuous_update=False,
    style={'description_width': '130px'},
    layout=Layout(width='400px')
)

maxPowerSlider = FloatSlider(
    min=0, max=100, step=0.5, value=99.5,
    description='Max Power:',
    continuous_update=False,
    style={'description_width': '130px'},
    layout=Layout(width='400px')
)

minPowerSlider = FloatSlider(
    min=0, max=100, step=0.5, value=0,
    description='Min Power:',
    continuous_update=False,
    style={'description_width': '130px'},
    layout=Layout(width='400px', padding='50px 0px 0px 0px')
)

sigmaSlider = FloatSlider(
    min=0, max=10, step=0.1, value=4.0,
    description='Sigma :',
    continuous_update=False,
    style={'description_width': '130px'},
    layout=Layout(width='400px')
)

svdSelector = ToggleButtons(
    options=['Standard','Random', 'Adaptive'],
    description='SVD Mode:',
    button_style='',
    tooltips=['Randomized decomposition', 'Basic SVD', 'Adaptive approach'],
)

ensembleSize = IntSlider(
    min=0, max=256, step=1, value=256,
    description='Ensemble Size:',
    continuous_update=False,
    style={'description_width': '130px'}
)

randomK = IntSlider(
    min=0, max=256, step=1, value=256,
    description='k:',
    continuous_update=False,
    style={'description_width': '130px'}
)

randomIters = IntSlider(
    min=0, max=256, step=1, value=256,
    description='Power Iters:',
    continuous_update=False,
    style={'description_width': '130px'}
)

randomD = IntSlider(
    min=0, max=256, step=1, value=256,
    description='d:',
    continuous_update=False,
    style={'description_width': '130px'}
)

adaptiveBlockSize = IntSlider(
    min=0, max=256, step=1, value=256,
    description='Block Size:',
    continuous_update=False,
    style={'description_width': '130px'}
)

adaptiveBlockOverlap = IntSlider(
    min=0, max=256, step=1, value=256,
    description='Block Overlap:',
    continuous_update=False,
    style={'description_width': '130px'}
)

adaptiveTissueThreshold = IntSlider(
    min=0, max=256, step=1, value=256,
    description='Tissue Threshold:',
    continuous_update=False,
    style={'description_width': '130px'}
)

adaptiveNoiseThreshold = IntSlider(
    min=0, max=256, step=1, value=256,
    description='Noise Threshold:',
    continuous_update=False,
    style={'description_width': '130px'}
)


interactive = interactive_output(update, {'tissue_threshold': tissueSlider, 'noise_threshold': noiseSlider, 'maxMag': maxPowerSlider, 'minMag': minPowerSlider, 'sigma':sigmaSlider, 'svdMode':svdSelector})

standInputs = VBox([standardSVDOutput, tissueSlider, noiseSlider, sigmaSlider, maxPowerSlider])

randInputs = VBox([randomK, randomIters, randomD])

adaptiveInputs = VBox([adaptiveBlockSize, adaptiveBlockOverlap, adaptiveTissueThreshold, adaptiveNoiseThreshold])

display(HBox([VBox([ensembleSize, svdSelector, standInputs, randInputs, adaptiveInputs, minPowerSlider]), bloodOut, powerDopplerOut]))

# display(HBox([VBox([ensembleSize, svdSelector, standInputs, minPowerSlider]), bloodOut, powerDopplerOut]))

# git
# 3d render
# adaptive with forces
# simpler filter